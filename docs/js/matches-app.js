document.addEventListener('alpine:init', () => {
    Alpine.data('matchesApp', () => ({
        frcMatches: [],
        scoutEntries: {},
        availableSeasons: FRC_CONFIG.seasons,
        availableEvents: FRC_CONFIG.events,
        selectedSeasons: [FRC_CONFIG.defaultSeason],
        selectedEvents: [FRC_CONFIG.events.find(e => e.season === FRC_CONFIG.defaultSeason)?.key].filter(Boolean),
        selectedTypes: ['Qualification'],
        searchQuery: '',
        loading: true,
        errorMessage: '',
        expandedMatches: [],
        expandedReports: [],
        teamDataCache: {},
        manualTeams: {},

        async init() {
            try {
                this.manualTeams = await loadManualTeams();

                this.$watch('selectedEvents', () => {
                    this.fetchMatches(); // No longer awaited since Alpine handles the re-render reactivity 
                });

                this.$watch('selectedSeasons', () => {
                    // Changing season can change the available events, but we just trigger a refetch
                    // the filteredMatches computed function handles the visual filtering.
                    this.fetchMatches();
                });

                await this.fetchMatches();

                db.collection('scouting').onSnapshot(snapshot => {
                    this.scoutEntries = {};
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        data.id = doc.id; // Store Firestore ID
                        if (data.matchNumber) {
                            const matchType = data.meta?.matchType || 'Qualification';
                            const key = `${data.regional}_${matchType}_${data.matchNumber}`;
                            if (!this.scoutEntries[key]) this.scoutEntries[key] = [];
                            this.scoutEntries[key].push(data);
                        }
                    });
                    this.loading = false;
                }, err => {
                    this.errorMessage = 'Firestore connection failed';
                    this.loading = false;
                });
            } catch (err) {
                console.error("Init Error:", err);
                this.errorMessage = 'Failed to initialize matches: ' + err.message;
                this.loading = false;
            }
        },

        async fetchMatches() {
            this.loading = true;
            this.errorMessage = '';
            try {
                // Fetch matches for all selected events
                const allMatches = await Promise.all(
                    this.selectedEvents.map(key => fetchFRCMatches(key))
                );
                // Flatten and add event key to each match for filtering
                this.frcMatches = allMatches.flatMap((matches, i) =>
                    matches.map(m => ({ ...m, eventKey: this.selectedEvents[i] }))
                );
                this.frcMatches.sort((a, b) => {
                    const weights = { 'p': 0, 'qm': 1, 'qf': 2, 'sf': 3, 'f': 4 };
                    const wA = weights[a.compLevel] || 1;
                    const wB = weights[b.compLevel] || 1;
                    if (wA !== wB) return wA - wB;
                    return a.matchNumber - b.matchNumber;
                });
            } catch (e) {
                console.error("Error fetching matches:", e);
                this.errorMessage = 'Failed to fetch matches updates from API';
            } finally {
                this.loading = false;
            }
        },

        toggleMatch(key) {
            if (this.expandedMatches.includes(key)) {
                this.expandedMatches = this.expandedMatches.filter(k => k !== key);
            } else {
                this.expandedMatches.push(key);
            }
        },

        toggleReport(id) {
            if (this.expandedReports.includes(id)) {
                this.expandedReports = this.expandedReports.filter(i => i !== id);
            } else {
                this.expandedReports.push(id);
                this.loadScouterTeamData(id);
            }
        },

        filteredMatches() {
            const scoutedKeys = Object.keys(this.scoutEntries);

            let list = this.frcMatches.map(m => {
                const type = m.compLevel === 'qm' ? 'Qualification' :
                    m.compLevel === 'p' ? 'Practice' : 'Playoffs';
                const eventShort = this.availableEvents.find(e => e.key === m.eventKey)?.name.split(' ')[0] || m.eventKey;
                const year = this.availableEvents.find(e => e.key === m.eventKey)?.season || '';

                return {
                    ...m,
                    type,
                    eventShort,
                    year,
                    isManual: false
                };
            });

            scoutedKeys.forEach(key => {
                const [regional, scoutType, matchNumStr] = key.split('_');
                const matchNum = Number(matchNumStr);

                // Map frontend scouted Type back to TBA compLevel
                let scoutCompLevel = 'qm';
                if (scoutType === 'Practice') scoutCompLevel = 'p';
                if (scoutType === 'Playoffs') scoutCompLevel = 'sf';

                // Look for an existing API match that is strictly matching BOTH event + matchNumber AND match type!
                const existingApiMatchListIndex = list.findIndex(m =>
                    m.eventKey === regional &&
                    m.matchNumber === matchNum &&
                    (
                        (scoutType === 'Practice' && m.compLevel === 'p') ||
                        (scoutType === 'Qualification' && m.compLevel === 'qm') ||
                        (scoutType === 'Playoffs' && ['qf', 'sf', 'f'].includes(m.compLevel))
                    )
                );

                const entries = this.scoutEntries[key];

                if (existingApiMatchListIndex === -1) {
                    const eventObj = this.availableEvents.find(e => e.key === regional);

                    list.push({
                        matchNumber: matchNum,
                        eventKey: regional,
                        eventShort: eventObj?.name.split(' ')[0] || regional,
                        year: eventObj?.season || '',
                        type: scoutType,
                        description: `${scoutType} ${matchNum}`,
                        compLevel: scoutCompLevel,
                        teams: [],
                        isManual: true,
                        scoutedTeams: entries.map(e => e.teamNumber)
                    });
                } else {
                    // Update type of existing match if it only exists in scout data with different type assumption
                    const mInfo = list[existingApiMatchListIndex];
                    if (mInfo && mInfo.isManual) {
                        mInfo.type = scoutType;
                    }
                }
            });

            return list.filter(m => {
                // Event Filter
                if (this.selectedEvents.length > 0 && !this.selectedEvents.includes(m.eventKey)) return false;

                // Type Filter
                const isPractice = m.compLevel === 'p' || m.type === 'Practice';
                const isQual = m.compLevel === 'qm' || m.type === 'Qualification';
                const isPlayoff = ['qf', 'sf', 'f'].includes(m.compLevel) || m.type === 'Playoffs';

                let typeMatch = false;
                if (this.selectedTypes.includes('Practice') && isPractice) typeMatch = true;
                if (this.selectedTypes.includes('Qualification') && isQual) typeMatch = true;
                if (this.selectedTypes.includes('Playoffs') && isPlayoff) typeMatch = true;

                if (!typeMatch) return false;

                // Search Query Filter
                if (this.searchQuery) {
                    const matchNumMatch = m.matchNumber.toString() === this.searchQuery;
                    const teamMatch = m.teams?.some(t => t.teamNumber.toString().includes(this.searchQuery)) ||
                        m.scoutedTeams?.some(t => t.toString().includes(this.searchQuery));
                    if (!matchNumMatch && !teamMatch) return false;
                }
                return true;
            }).sort((a, b) => {
                if (b.year !== a.year) return b.year - a.year;
                const weights = { 'p': 0, 'qm': 1, 'qf': 2, 'sf': 3, 'f': 4 };
                const wA = weights[a.compLevel] || 1;
                const wB = weights[b.compLevel] || 1;
                if (wA !== wB) return wA - wB;
                return a.matchNumber - b.matchNumber;
            });
        },

        isHighlighted(teamNumber) {
            if (!this.searchQuery) return false;
            return teamNumber.toString().includes(this.searchQuery);
        },

        getScoringRules(year) {
            return FRC_CONFIG.scoring[year] || FRC_CONFIG.scoring[FRC_CONFIG.defaultSeason];
        },

        // Parses "5-10" or "10" into a numeric average or value
        parseFuel(val) {
            if (!val) return 0;
            if (typeof val === 'number') return val;
            if (typeof val === 'string') {
                if (val.includes('-')) {
                    const parts = val.split('-').map(p => parseInt(p));
                    return (parts[0] + parts[1]) / 2; // Use average for score estimation
                }
                return parseInt(val) || 0;
            }
            return 0;
        },

        calculateScores(entry, year) {
            if (!entry) return { auto: 0, teleop: 0, endgame: 0, totalFuel: 0, total: 0 };

            // In 2026, scoring rules might vary. Defaulting to points per action.
            // L1/Net (2pts), L2/L3/Proc (3/4/6pts), L4 (5pts)

            // Auto
            let autoPoints = 0;
            autoPoints += (entry.auto?.l1 || 0) * 3;
            autoPoints += (entry.auto?.l2 || 0) * 4;
            autoPoints += (entry.auto?.l3 || 0) * 6;
            autoPoints += (entry.auto?.l4 || 0) * 7;
            autoPoints += (entry.auto?.net || 0) * 4;
            autoPoints += (entry.auto?.processor || 0) * 6;
            if (entry.auto?.level1 === 'success') autoPoints += 3; // Leave line

            // Teleop (Shifts A/B logic -> Coral/Algae equivalent proxy mapping for now based on previous var reuse by user)
            // Wait, looking at the code, in scout-app transitionShift is L1, teleopShiftA is L2, teleopShiftB is L3, etc.
            let teleopPoints = 0;
            teleopPoints += (entry.transitionShift || 0) * 2; // L1 Proxy
            teleopPoints += (entry.teleopShiftA || 0) * 3; // L2 Proxy
            teleopPoints += (entry.teleopShiftB || 0) * 4; // L3 Proxy

            // Endgame
            let endgamePoints = 0;
            const level = entry.endgame?.level?.toLowerCase();
            if (level === 'park') endgamePoints = 2;
            else if (level === 'shallow') endgamePoints = 6;
            else if (level === 'deep') endgamePoints = 12;

            return {
                auto: autoPoints,
                teleop: teleopPoints,
                endgame: endgamePoints,
                totalFuel: 0,
                total: autoPoints + teleopPoints + endgamePoints
            };
        },

        isVerified(role) {
            return role && role !== 'new';
        },

        formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            // Handle Firestore Timestamp vs Date
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        },

        async loadScouterTeamData(id) {
            // Optional: Fetch team logo/name for scouter team if needed
        }
    }));
});
